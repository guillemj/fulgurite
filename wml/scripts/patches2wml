#!/usr/bin/perl
#
# patches2wml <patchdir>
#
# Generates a wml list of patches in rfc822 format from patchdir.
#
# Copyright Â© 2003-2005, 2007-2008  Guillem Jover <guillem@hadrons.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#

use warnings;
use strict;
use Digest::MD5 qw(md5_hex);

my @excluded_fields = qw(
	Author From Date Content-Type Content-Transfer-Encoding MIME-Version
);
my @status_list = qw(
	not_sent sent applied fixed obsolete rejected unknown
);
my %status_info = (
	not_sent => 'Patches not sent',
	sent => 'Patches sent',
	applied => 'Patches applied',
	fixed => 'Patches modified or fixed in a different way',
	obsolete => 'Patches made obsolete by other changes or project bitrot',
	rejected => 'Patches rejected',
	unknown => 'Unknown',
);

sub parse_patch($$)
{
	my $filename = shift;
	my $title = shift;
	my $patchname = md5_hex($filename);
	my $status = "unknown";
	my $format = "old";

	print "{#patch_$patchname#:\n";
	print "  <patch>\n";
	print "    <patch-title href=\"$filename\">$title</patch-title>\n";
	print "    <patch-description>\n";

	my $prev_field = "empty";

	open(INFILE, $filename) or die "Cannot open $filename: $!";

	line: while (<INFILE>) {
		chomp;
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;

		# End of RFC822 header data
		last if !length;

		if (/^From /) {
			$format = "git";
		} elsif ($prev_field eq "Description" and /^ /) {
			s/^ \./<br \/>/;
			s/([.:])$/$1<br \/>/;
			print $_, "\n";
		} elsif (/^([^ +-][^: ]*): *(.*)$/) { # Split the line
			my $field = $1;
			my $content = $2;

			# Don't show excluded fields
			next line if grep(/$field/, @excluded_fields);

			if ($format eq "git") {
				if ($field eq "Subject") {
					$field = "Description";
					$content =~ s/\[PATCH.*\] //;
				}
			}

			if ($field eq "Status") {
				($status = $content) =~ tr/- A-Z/__a-z/;
			}

			if ($field eq "Debbug") {
				$content = "<debbug $content>";
			}

			print "</li>\n" if ($prev_field ne "empty");
			print "      <li><strong>$field: $content</strong>";

			print " <br />\n" if ($field eq "Description");

			$prev_field = $field;
		} else {
			last if !defined $1;
		}
	}

	close INFILE;

	print "      </li>\n" if ($prev_field ne "empty");
	print "    </patch-description>\n";
	print "  </patch>\n";
	print "\n";
	print ":##}\n";

	print "<increment n_$status />\n";
	print "{#patch_list_$status#:\n";
	print "  {#patch_$patchname#}\n";
	print ":##}\n";
}

sub print_status_counter($)
{
	my $status = shift;

	print "<set-var n_$status=0 />\n";
}

sub print_status_summary($)
{
	my $status = shift;
	my $status_name = $status;
	my $status_note = $status_info{$status};

	$status_name =~ tr/_/ /;

	print "{#patch_toc#:\n";
	print "<toc-entry href=\"#$status\">$status_name ($status_note)</toc-entry>\n";
	print ":##}\n";

	print "{#patch_list#:\n";
	print "<div class=\"patches_$status\">\n";
	print "  <h3 id=\"$status\">Patches $status_name</h3>\n";
	print "  {#patch_list_$status#}\n";
	print "</div>\n";
	print ":##}\n";

	print "{#patch_summary#:\n";
	print "  <li><a href=\"#$status\">$status_note</a> [$status_name] (<get-var n_$status />)</li>\n";
	print ":##}\n";
}

sub parse_patchdir($)
{
	my $patchdir = shift;

	foreach (@status_list) {
		print_status_counter($_);
	}

	open CMD, "find $patchdir/ -name '*.patch' | sort |";
	while (<CMD>) {
		chomp;

		my $patch = $_;
		$patch =~ s/^\.\///;
		my $title = $_;
		$title =~ s/^$patchdir\///;

		parse_patch($patch, $title);
	}
	close CMD;

	foreach (@status_list) {
		print_status_summary($_);
	}
}

my $patchdir = $ARGV[0];

if (-d $patchdir) {
	parse_patchdir($patchdir);
} else {
	die "Argument '$patchdir' is not a directory: $!";
}
