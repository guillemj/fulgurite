#!/usr/bin/perl
#
# patches2wml patchdir
#
#	Generates a wml list of patches in rfc822 format from patchdir.
#	The patch title is the patch filename with the patchdir stripped.
#
# Copyright (C) 2003-2005, 2007-2008 Guillem Jover <guillem@hadrons.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#

use warnings;
use strict;
use Digest::MD5 qw(md5_hex);

my @excluded_fields = ("Author");
my @status_list = ("not_sent", "sent", "applied", "fixed", "rejected", "unknown");

sub parse_patch($$)
{
	my $filename = shift;
	my $title = shift;
	my $patchname = md5_hex($filename);
	my $status = "unknown";

	print "{#patch_$patchname#:\n";
	print "  <patch>\n";
	print "    <patch-title href=\"$filename\">$title</patch-title>\n";
	print "    <patch-description>\n";

	my $prev_field = "empty";

	open(INFILE, $filename) or die "Cannot open $filename: $!";

	line: while (<INFILE>) {
		chomp;
		s/&/&amp;/g;
		s/</&lt;/g;
		s/>/&gt;/g;

		# End of RFC822 header data
		last if !length;

		if ($prev_field eq "Description" and /^ /) {
			s/^ \./<br \/>/;
			s/([.:])$/$1<br \/>/;
			print $_, "\n";
		} elsif (/^([^: ]*): *(.*)$/) { # Split the line
			my $field = $1;
			my $content = $2;

			# Don't show excluded fields
			next line if grep(/$field/, @excluded_fields);

			if ($field eq "Status") {
				($status = $content) =~ tr/- A-Z/__a-z/;
			}

			if ($field eq "Debbug") {
				$content = "<debbug $content>";
			}

			print "</li>\n" if ($prev_field ne "empty");
			print "      <li><strong>$field: $content</strong>";

			print " <br />\n" if ($field eq "Description");

			$prev_field = $field;
		} else {
			last if !defined $1;
		}
	}

	close INFILE;

	print "      </li>\n" if ($prev_field ne "empty");
	print "    </patch-description>\n";
	print "  </patch>\n";
	print "\n";
	print ":##}\n";

	print "<increment n_$status />\n";
	print "{#patch_list_$status#:\n";
	print "  {#patch_$patchname#}\n";
	print ":##}\n";
}

sub print_status_counter($)
{
	my $status = shift;

	print "<set-var n_$status=0 />\n";
}

sub print_status_summary($)
{
	my $status = shift;
	my $status_note = $status;

	$status_note =~ tr/_/ /;

	print "{#patch_toc#:\n";
	print "<toc-entry href=\"#$status\">$status_note</toc-entry>\n";
	print ":##}\n";

	print "{#patch_list#:\n";
	print "<div class=\"patches_$status\">\n";
	print "  <h3 id=\"$status\">Patches $status_note</h3>\n";
	print "  {#patch_list_$status#}\n";
	print "</div>\n";
	print ":##}\n";

	print "{#patch_summary#:\n";
	print "  <li><a href=\"#$status\">$status_note</a> (<get-var n_$status />)</li>\n";
	print ":##}\n";
}

sub parse_patchdir($)
{
	my $patchdir = shift;

	foreach (@status_list) {
		print_status_counter($_);
	}

	open CMD, "find $patchdir/ -name '*.patch' | sort |";
	while (<CMD>) {
		chomp;

		my $patch = $_;
		$patch =~ s/^\.\///;
		my $title = $_;
		$title =~ s/^$patchdir\///;

		parse_patch($patch, $title);
	}
	close CMD;

	foreach (@status_list) {
		print_status_summary($_);
	}
}

my $patchdir = $ARGV[0];

if (-d $patchdir) {
	parse_patchdir($patchdir);
} else {
	die "Argument '$patchdir' is not a directory: $!";
}

